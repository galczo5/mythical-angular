<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Mythical Angular</title><link>https://mythical-angular.dev/posts/</link><description>Recent content in Posts on Mythical Angular</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Kamil Gałek</copyright><lastBuildDate>Wed, 23 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://mythical-angular.dev/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>What exactly esbuild is doing in Angular...?</title><link>https://mythical-angular.dev/posts/angular-15-esbuild/</link><pubDate>Wed, 23 Nov 2022 00:00:00 +0000</pubDate><guid>https://mythical-angular.dev/posts/angular-15-esbuild/</guid><description>Angular 15 was recently released. From blog post we know that the Angular team is working on bringing faster builds to the Angular ecosystem.
1 2 3 4 5 In v14 we announced the experimental support for esbuild in ng build to enable faster build times and simplify our pipeline. In v15 we now have experimental Sass, SVG template, file replacement, and ng build --watch support! Source
It looks like my dream is coming true.</description></item><item><title>How to create unit tests for code using `inject` without `TestBed`</title><link>https://mythical-angular.dev/posts/inject-testing/</link><pubDate>Wed, 12 Oct 2022 00:00:00 +0000</pubDate><guid>https://mythical-angular.dev/posts/inject-testing/</guid><description>inject function introduced in Angular 14, even with limitations is a very cool feature. But, where&amp;rsquo;s light there&amp;rsquo;s dark. When we inject everything into a constructor of the class, it&amp;rsquo;s easy to test it when you&amp;rsquo;re not using TestBed. After using inject it might be a bit complicated.
Luckily for us, it&amp;rsquo;s not impossible. What&amp;rsquo;s more, it&amp;rsquo;s very easy to make code with inject testable.
Repository As always, if you need my code, you&amp;rsquo;ll find it in the repository on GitHub: github.</description></item><item><title>Short: I had some time, so I checked how time-consuming is TesBed</title><link>https://mythical-angular.dev/posts/testbed-time/</link><pubDate>Tue, 09 Aug 2022 00:00:00 +0000</pubDate><guid>https://mythical-angular.dev/posts/testbed-time/</guid><description>This is going to be short. I cannot stop thinking about my last results from the previous article. I was able to use esbuild instead of ts-jest, and it was still slow.
It looked like using TestBed is time-consuming. So I decided to check it, and I&amp;rsquo;m ready to show you the results.
The test For testing, I used the same repository. You can find it on my GitHub: ng-esbuild-unit-tests.</description></item><item><title>It looks that TestBed works with esbuild</title><link>https://mythical-angular.dev/posts/ngc-esbuild-jest/</link><pubDate>Mon, 08 Aug 2022 00:00:00 +0000</pubDate><guid>https://mythical-angular.dev/posts/ngc-esbuild-jest/</guid><description>In previous post &amp;ldquo;esbuild against TestBed&amp;rdquo; I said that TestBed is not working when we use esbuild to bundle tests. It seems like it&amp;rsquo;s possible to work around the problems.
I said also that I&amp;rsquo;m not sure what to think about the TestBed, is it worth using it or not. Every day, I&amp;rsquo;m closer to getting my own opinion. But this is a subject for the next post.
Today we will focus on how to compile our tests with esbuild and still be able to use TestBed.</description></item><item><title>esbuild against TestBed</title><link>https://mythical-angular.dev/posts/jest/</link><pubDate>Sun, 24 Jul 2022 00:00:00 +0000</pubDate><guid>https://mythical-angular.dev/posts/jest/</guid><description>Isn&amp;rsquo;t the unit testing the most basic technique and one of the more important aspects of programing these days? During my days as a .NET developer, I learned a few things about unit testing:
Unit tests have to be FAST. If they are not fast, you&amp;rsquo;re going to be irritated, and you&amp;rsquo;ll waste a lot of time. You have to ISOLATE your unit tests from the source code. If not, changes in the source code may affect tests and change the requirement behind the test.</description></item><item><title>Not a myth: Using fields instead of methods in templates is good for the performance</title><link>https://mythical-angular.dev/posts/functions/</link><pubDate>Mon, 04 Jul 2022 00:00:00 +0000</pubDate><guid>https://mythical-angular.dev/posts/functions/</guid><description>So, this article is a bit different. This time, I&amp;rsquo;m describing a very popular technique of optimization in Angular that is actually not a myth.
The whole idea is to use fields instead of methods in templates, because to get value from a function you have to execute it. Using methods makes memoization not possible etc. In the end, do you really have to care about it?
The test To test this hypothesis, I&amp;rsquo;ve created an example app.</description></item><item><title>What you can do with Angular 14 inject</title><link>https://mythical-angular.dev/posts/togglers/</link><pubDate>Sun, 26 Jun 2022 00:00:00 +0000</pubDate><guid>https://mythical-angular.dev/posts/togglers/</guid><description>Since last article, I was wondering what to do with the inject function. For sure, it&amp;rsquo;s quite limited. We can use it only during construction of the component.
Today I want to show you something, what I think, might be pretty useful. Especially if you&amp;rsquo;re working on a bigger project, and you care about the runtime performance.
The problem What&amp;rsquo;s the problem with the @HostBinding&amp;hellip;? You need to trigger change detection to apply the effect.</description></item><item><title>Angular 14 `inject()` implementation analysis</title><link>https://mythical-angular.dev/posts/inject/</link><pubDate>Fri, 03 Jun 2022 00:00:00 +0000</pubDate><guid>https://mythical-angular.dev/posts/inject/</guid><description>Angular 14 brings us a very cool feature, function which we can use to inject our dependencies. First time, I read about it in an article written by Netanel Basal. It looked very cool and a little mysterious. Now, when Angular 14 is officially released, we can check how it works and how they implemented it.
In the article, Netanel described inject() interesting behaviour:
First, inject() can only be called in the constructor, so we can’t leverage a component’s inputs.</description></item><item><title>Myth: There is no difference between ApplicationRef.tick() and ChangeDetectorRef.detectChanges()</title><link>https://mythical-angular.dev/posts/tick-vs-detect-changes/</link><pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate><guid>https://mythical-angular.dev/posts/tick-vs-detect-changes/</guid><description>&amp;ldquo;I use ApplicationRef.tick() because it works, and after all, there is no difference&amp;rdquo;
Come on. These kinds of sentences almost always are not true. In this article I will show you how big difference is between ApplicationRef.tick and ChangeDetectorRef.detectChanges.
Please remember that all my research is focused on using Angular in &amp;ldquo;high-performance&amp;rdquo; mode. For normal usage, simple webpages or small apps, there is a difference, of course, but I doubt that we should care about it.</description></item><item><title>Code analysis: NgZone vs NoopNgZone</title><link>https://mythical-angular.dev/posts/ngzones/</link><pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate><guid>https://mythical-angular.dev/posts/ngzones/</guid><description>In previous articles I described how to start creating Angular apps using noop zone instead NgZone. The text below describes the technical difference in implementation between NgZone and NoopNgZone. In my opinion, it&amp;rsquo;s quite important to know that difference because it helps to understand how change detections work.
NgZone I decided to remove some comments from the code, so it should be easier to read. Check out the packages/core/src/zone/ng_zone.ts file in Angular repository for the full version.</description></item><item><title>Tutorial: How to start zone-less Angular app</title><link>https://mythical-angular.dev/posts/zoneless/</link><pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate><guid>https://mythical-angular.dev/posts/zoneless/</guid><description>Well, hello again!
This time I decided to do something else that usual. Today I will not try to describe and demystify any Angular-related myth, because today I will show you a simple tutorial how to start a new Angular app without NgZones.
Generating new app There is no reason to describe it very deeply. It&amp;rsquo;s just a standard ng new command. In my example, I&amp;rsquo;m using routing. First, you probably use router too, and I want to make this example as simple as possible, but still pretty close to real-life apps.</description></item><item><title>Myth: Component styles</title><link>https://mythical-angular.dev/posts/styles/</link><pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate><guid>https://mythical-angular.dev/posts/styles/</guid><description>This is a very short and interesting subject to me. In Angular every component can have its own attached styles. Styles can be in the same file or in separated files, similar to the templates.
In addition, we can encapsulate styles. There are two methods of encapsulation: Emulated and ShadowDom. This article describes both types of encapsulation, and its influence on the performance of the whole app.
Using styles instead of styleUrls is good for performance Just before we start with the &amp;ldquo;complicated&amp;rdquo; stuff, I want to mention one of the myths connected to the place where you can put your style.</description></item><item><title>Myth: Styling method doesn't matter</title><link>https://mythical-angular.dev/posts/renderer/</link><pubDate>Mon, 21 Feb 2022 00:00:00 +0000</pubDate><guid>https://mythical-angular.dev/posts/renderer/</guid><description>Today I&amp;rsquo;m going to show you how to test different methods of html styling in Angular. You&amp;rsquo;re going to learn what is Renderer2, how and when to it and of course how it&amp;rsquo;s implemented in the framework. I&amp;rsquo;m going to compare different approaches of adding styles to find the best one. You&amp;rsquo;ll see that it&amp;rsquo;s not that simple.
Angular build-in directives At the very beginning, when you learn about Angular styling.</description></item><item><title>Myth: Change Detection Strategies</title><link>https://mythical-angular.dev/posts/change-detection-strategies/</link><pubDate>Sun, 20 Feb 2022 00:00:00 +0000</pubDate><guid>https://mythical-angular.dev/posts/change-detection-strategies/</guid><description>Not so long ago I noticed that the change detection subject in Angular is very mythical. For the first sight, it looks very simple, and it is.
Docs So, we have two change detection strategies: Default and OnPush. If you have not specified which one you want to use in your component, it&amp;rsquo;s going to use Default one. Our experiment we should start with the docs.
As you can see, the documentation is not that easy to base here only on the docs.</description></item><item><title>Myth: Using set instead ngOnChanges improves the performance</title><link>https://mythical-angular.dev/posts/setters/</link><pubDate>Sun, 06 Feb 2022 00:00:00 +0000</pubDate><guid>https://mythical-angular.dev/posts/setters/</guid><description>Introduction Why using sets instead of ngOnChanges is considered as a good practice&amp;hellip;? I&amp;rsquo;m not sure, but I heard it so many times that I decided to check it. Thanks to luck, I found the root of this myth.
The myth It all started when I asked a frontend developer about practices that are helpful with dealing with the Angular performance problems. One of the things he said was that using sets on inputs is a performance tweak.</description></item><item><title>Myth: Async pipes are good for performance</title><link>https://mythical-angular.dev/posts/async-pipe/</link><pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate><guid>https://mythical-angular.dev/posts/async-pipe/</guid><description>Introduction Async pipes are considered a very good practice as they help with web performance problems and btw are easy to use. Sounds very cool, right?
Unfortunately, it&amp;rsquo;s not true. It would be so good to use async pipes everywhere and don&amp;rsquo;t worry about any observable related performance problems.
Before I&amp;rsquo;ll start to explain what the problem with async pipe is, let&amp;rsquo;s check how it&amp;rsquo;s implemented.
AsyncPipe source code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 /** * @license * Copyright Google LLC All Rights Reserved.</description></item><item><title>Intro - What is 'Mythical Angular'</title><link>https://mythical-angular.dev/posts/intro/</link><pubDate>Thu, 27 Jan 2022 00:00:00 +0000</pubDate><guid>https://mythical-angular.dev/posts/intro/</guid><description>1 2 3 4 5 6 function main() { return &amp;#39;Hello world!&amp;#39;; } const result = main(); console.info(result); Hi all!
My name is Kamil Gałek, and I&amp;rsquo;m a frontend developer. My daily work is based mostly on the Angular framework. I had that opportunity to learn a lot from my more experienced colleagues, and I think it&amp;rsquo;s time to share what I know.
I&amp;rsquo;m a technical recruiter too. I decided to create this page because I found that there are some myths about Angular and its internals.</description></item></channel></rss>