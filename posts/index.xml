<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Mythical Angular</title><link>https://galczo5.github.io/mythical-angular/posts/</link><description>Recent content in Posts on Mythical Angular</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Kamil Gałek</copyright><lastBuildDate>Sun, 26 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://galczo5.github.io/mythical-angular/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>What you can do with Angular 14 inject</title><link>https://galczo5.github.io/mythical-angular/posts/togglers/</link><pubDate>Sun, 26 Jun 2022 00:00:00 +0000</pubDate><guid>https://galczo5.github.io/mythical-angular/posts/togglers/</guid><description>Since last article, I was wondering what to do with the inject function. For sure, it&amp;rsquo;s quite limited. We can use it only during construction of the component.
Today I want to show you something, what I think, might be pretty useful. Especially if you&amp;rsquo;re working on a bigger project, and you care about the runtime performance.
The problem What&amp;rsquo;s the problem with the @HostBinding&amp;hellip;? You need to trigger change detection to apply the effect.</description></item><item><title>Angular 14 `inject()` implementation analysis</title><link>https://galczo5.github.io/mythical-angular/posts/inject/</link><pubDate>Fri, 03 Jun 2022 00:00:00 +0000</pubDate><guid>https://galczo5.github.io/mythical-angular/posts/inject/</guid><description>Angular 14 brings us a very cool feature, function which we can use to inject our dependencies. First time, I read about it in an article written by Netanel Basal. It looked very cool and a little mysterious. Now, when Angular 14 is officially released, we can check how it works and how they implemented it.
In the article, Netanel described inject() interesting behaviour:
First, inject() can only be called in the constructor, so we can’t leverage a component’s inputs.</description></item><item><title>Myth: There is no difference between ApplicationRef.tick() and ChangeDetectorRef.detectChanges()</title><link>https://galczo5.github.io/mythical-angular/posts/tick-vs-detect-changes/</link><pubDate>Sat, 21 May 2022 00:00:00 +0000</pubDate><guid>https://galczo5.github.io/mythical-angular/posts/tick-vs-detect-changes/</guid><description>&amp;ldquo;I use ApplicationRef.tick() because it works, and after all, there is no difference&amp;rdquo;
Come on. These kinds of sentences almost always are not true. In this article I will show you how big difference is between ApplicationRef.tick and ChangeDetectorRef.tick.
Please remember that all my research is focused on using Angular in &amp;ldquo;high-performance&amp;rdquo; mode. For normal usage, simple webpages or small apps, there is a difference, of course, but I doubt that we should care about it.</description></item><item><title>Code analysis: NgZone vs NoopNgZone</title><link>https://galczo5.github.io/mythical-angular/posts/ngzones/</link><pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate><guid>https://galczo5.github.io/mythical-angular/posts/ngzones/</guid><description>In previous articles I described how to start creating Angular apps using noop zone instead NgZone. The text below describes the technical difference in implementation between NgZone and NoopNgZone. In my opinion, it&amp;rsquo;s quite important to know that difference because it helps to understand how change detections work.
NgZone I decided to remove some comments from the code, so it should be easier to read. Check out the packages/core/src/zone/ng_zone.ts file in Angular repository for the full version.</description></item><item><title>Tutorial: How to start zone-less Angular app</title><link>https://galczo5.github.io/mythical-angular/posts/zoneless/</link><pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate><guid>https://galczo5.github.io/mythical-angular/posts/zoneless/</guid><description>Well, hello again!
This time I decided to do something else that usual. Today I will not try to describe and demystify any Angular-related myth, because today I will show you a simple tutorial how to start a new Angular app without NgZones.
Generating new app There is no reason to describe it very deeply. It&amp;rsquo;s just a standard ng new command. In my example, I&amp;rsquo;m using routing. First, you probably use router too, and I want to make this example as simple as possible, but still pretty close to real-life apps.</description></item><item><title>Myth: Component styles</title><link>https://galczo5.github.io/mythical-angular/posts/styles/</link><pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate><guid>https://galczo5.github.io/mythical-angular/posts/styles/</guid><description>This is a very short and interesting subject to me. In Angular every component can have its own attached styles. Styles can be in the same file or in separated files, similar to the templates.
In addition, we can encapsulate styles. There are two methods of encapsulation: Emulated and ShadowDom. This article describes both types of encapsulation, and its influence on the performance of the whole app.
Using styles instead of styleUrls is good for performance Just before we start with the &amp;ldquo;complicated&amp;rdquo; stuff, I want to mention one of the myths connected to the place where you can put your style.</description></item><item><title>Myth: Styling method doesn't matter</title><link>https://galczo5.github.io/mythical-angular/posts/renderer/</link><pubDate>Mon, 21 Feb 2022 00:00:00 +0000</pubDate><guid>https://galczo5.github.io/mythical-angular/posts/renderer/</guid><description>Today I&amp;rsquo;m going to show you how to test different methods of html styling in Angular. You&amp;rsquo;re going to learn what is Renderer2, how and when to it and of course how it&amp;rsquo;s implemented in the framework. I&amp;rsquo;m going to compare different approaches of adding styles to find the best one. You&amp;rsquo;ll see that it&amp;rsquo;s not that simple.
Angular build-in directives At the very beginning, when you learn about Angular styling.</description></item><item><title>Myth: Change Detection Strategies</title><link>https://galczo5.github.io/mythical-angular/posts/change-detection-strategies/</link><pubDate>Sun, 20 Feb 2022 00:00:00 +0000</pubDate><guid>https://galczo5.github.io/mythical-angular/posts/change-detection-strategies/</guid><description>Not so long ago I noticed that the change detection subject in Angular is very mythical. For the first sight, it looks very simple, and it is.
Docs So, we have two change detection strategies: Default and OnPush. If you have not specified which one you want to use in your component, it&amp;rsquo;s going to use Default one. Our experiment we should start with the docs.
As you can see, the documentation is not that easy to base here only on the docs.</description></item><item><title>Myth: Using set instead ngOnChanges improves the performance</title><link>https://galczo5.github.io/mythical-angular/posts/setters/</link><pubDate>Sun, 06 Feb 2022 00:00:00 +0000</pubDate><guid>https://galczo5.github.io/mythical-angular/posts/setters/</guid><description>Introduction Why using sets instead of ngOnChanges is considered as a good practice&amp;hellip;? I&amp;rsquo;m not sure, but I heard it so many times that I decided to check it. Thanks to luck, I found the root of this myth.
The myth It all started when I asked a frontend developer about practices that are helpful with dealing with the Angular performance problems. One of the things he said was that using sets on inputs is a performance tweak.</description></item><item><title>Myth: Async pipes are good for performance</title><link>https://galczo5.github.io/mythical-angular/posts/async-pipe/</link><pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate><guid>https://galczo5.github.io/mythical-angular/posts/async-pipe/</guid><description>Introduction Async pipes are considered a very good practice as they help with web performance problems and btw are easy to use. Sounds very cool, right?
Unfortunately, it&amp;rsquo;s not true. It would be so good to use async pipes everywhere and don&amp;rsquo;t worry about any observable related performance problems.
Before I&amp;rsquo;ll start to explain what the problem with async pipe is, let&amp;rsquo;s check how it&amp;rsquo;s implemented.
AsyncPipe source code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 /** * @license * Copyright Google LLC All Rights Reserved.</description></item><item><title>Intro - What is 'Mythical Angular'</title><link>https://galczo5.github.io/mythical-angular/posts/intro/</link><pubDate>Thu, 27 Jan 2022 00:00:00 +0000</pubDate><guid>https://galczo5.github.io/mythical-angular/posts/intro/</guid><description>1 2 3 4 5 6 function main() { return &amp;#39;Hello world!&amp;#39;; } const result = main(); console.info(result); Hi all!
My name is Kamil Gałek, and I&amp;rsquo;m a frontend developer. My daily work is based mostly on the Angular framework. I had that opportunity to learn a lot from my more experienced colleagues, and I think it&amp;rsquo;s time to share what I know.
I&amp;rsquo;m a technical recruiter too. I decided to create this page because I found that there are some myths about Angular and its internals.</description></item></channel></rss>